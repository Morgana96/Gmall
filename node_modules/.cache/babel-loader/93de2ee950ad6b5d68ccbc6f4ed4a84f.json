{"ast":null,"code":"import Utils from '../../../utils/utils';\nexport default function (event) {\n  const swiper = this;\n  const data = swiper.touchEventsData;\n  const {\n    params,\n    touches,\n    rtlTranslate: rtl,\n    $wrapperEl,\n    slidesGrid,\n    snapGrid\n  } = swiper;\n  let e = event;\n  if (e.originalEvent) e = e.originalEvent;\n\n  if (data.allowTouchCallbacks) {\n    swiper.emit('touchEnd', e);\n  }\n\n  data.allowTouchCallbacks = false;\n\n  if (!data.isTouched) {\n    if (data.isMoved && params.grabCursor) {\n      swiper.setGrabCursor(false);\n    }\n\n    data.isMoved = false;\n    data.startMoving = false;\n    return;\n  } // Return Grab Cursor\n\n\n  if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n    swiper.setGrabCursor(false);\n  } // Time diff\n\n\n  const touchEndTime = Utils.now();\n  const timeDiff = touchEndTime - data.touchStartTime; // Tap, doubleTap, Click\n\n  if (swiper.allowClick) {\n    swiper.updateClickedSlide(e);\n    swiper.emit('tap', e);\n\n    if (timeDiff < 300 && touchEndTime - data.lastClickTime > 300) {\n      if (data.clickTimeout) clearTimeout(data.clickTimeout);\n      data.clickTimeout = Utils.nextTick(() => {\n        if (!swiper || swiper.destroyed) return;\n        swiper.emit('click', e);\n      }, 300);\n    }\n\n    if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {\n      if (data.clickTimeout) clearTimeout(data.clickTimeout);\n      swiper.emit('doubleTap', e);\n    }\n  }\n\n  data.lastClickTime = Utils.now();\n  Utils.nextTick(() => {\n    if (!swiper.destroyed) swiper.allowClick = true;\n  });\n\n  if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {\n    data.isTouched = false;\n    data.isMoved = false;\n    data.startMoving = false;\n    return;\n  }\n\n  data.isTouched = false;\n  data.isMoved = false;\n  data.startMoving = false;\n  let currentPos;\n\n  if (params.followFinger) {\n    currentPos = rtl ? swiper.translate : -swiper.translate;\n  } else {\n    currentPos = -data.currentTranslate;\n  }\n\n  if (params.freeMode) {\n    if (currentPos < -swiper.minTranslate()) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n\n    if (currentPos > -swiper.maxTranslate()) {\n      if (swiper.slides.length < snapGrid.length) {\n        swiper.slideTo(snapGrid.length - 1);\n      } else {\n        swiper.slideTo(swiper.slides.length - 1);\n      }\n\n      return;\n    }\n\n    if (params.freeModeMomentum) {\n      if (data.velocities.length > 1) {\n        const lastMoveEvent = data.velocities.pop();\n        const velocityEvent = data.velocities.pop();\n        const distance = lastMoveEvent.position - velocityEvent.position;\n        const time = lastMoveEvent.time - velocityEvent.time;\n        swiper.velocity = distance / time;\n        swiper.velocity /= 2;\n\n        if (Math.abs(swiper.velocity) < params.freeModeMinimumVelocity) {\n          swiper.velocity = 0;\n        } // this implies that the user stopped moving a finger then released.\n        // There would be no events with distance zero, so the last event is stale.\n\n\n        if (time > 150 || Utils.now() - lastMoveEvent.time > 300) {\n          swiper.velocity = 0;\n        }\n      } else {\n        swiper.velocity = 0;\n      }\n\n      swiper.velocity *= params.freeModeMomentumVelocityRatio;\n      data.velocities.length = 0;\n      let momentumDuration = 1000 * params.freeModeMomentumRatio;\n      const momentumDistance = swiper.velocity * momentumDuration;\n      let newPosition = swiper.translate + momentumDistance;\n      if (rtl) newPosition = -newPosition;\n      let doBounce = false;\n      let afterBouncePosition;\n      const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeModeMomentumBounceRatio;\n      let needsLoopFix;\n\n      if (newPosition < swiper.maxTranslate()) {\n        if (params.freeModeMomentumBounce) {\n          if (newPosition + swiper.maxTranslate() < -bounceAmount) {\n            newPosition = swiper.maxTranslate() - bounceAmount;\n          }\n\n          afterBouncePosition = swiper.maxTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.maxTranslate();\n        }\n\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\n      } else if (newPosition > swiper.minTranslate()) {\n        if (params.freeModeMomentumBounce) {\n          if (newPosition - swiper.minTranslate() > bounceAmount) {\n            newPosition = swiper.minTranslate() + bounceAmount;\n          }\n\n          afterBouncePosition = swiper.minTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.minTranslate();\n        }\n\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\n      } else if (params.freeModeSticky) {\n        let nextSlide;\n\n        for (let j = 0; j < snapGrid.length; j += 1) {\n          if (snapGrid[j] > -newPosition) {\n            nextSlide = j;\n            break;\n          }\n        }\n\n        if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {\n          newPosition = snapGrid[nextSlide];\n        } else {\n          newPosition = snapGrid[nextSlide - 1];\n        }\n\n        newPosition = -newPosition;\n      }\n\n      if (needsLoopFix) {\n        swiper.once('transitionEnd', () => {\n          swiper.loopFix();\n        });\n      } // Fix duration\n\n\n      if (swiper.velocity !== 0) {\n        if (rtl) {\n          momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);\n        } else {\n          momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);\n        }\n      } else if (params.freeModeSticky) {\n        swiper.slideToClosest();\n        return;\n      }\n\n      if (params.freeModeMomentumBounce && doBounce) {\n        swiper.updateProgress(afterBouncePosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n        swiper.animating = true;\n        $wrapperEl.transitionEnd(() => {\n          if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;\n          swiper.emit('momentumBounce');\n          swiper.setTransition(params.speed);\n          swiper.setTranslate(afterBouncePosition);\n          $wrapperEl.transitionEnd(() => {\n            if (!swiper || swiper.destroyed) return;\n            swiper.transitionEnd();\n          });\n        });\n      } else if (swiper.velocity) {\n        swiper.updateProgress(newPosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n\n        if (!swiper.animating) {\n          swiper.animating = true;\n          $wrapperEl.transitionEnd(() => {\n            if (!swiper || swiper.destroyed) return;\n            swiper.transitionEnd();\n          });\n        }\n      } else {\n        swiper.updateProgress(newPosition);\n      }\n\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    } else if (params.freeModeSticky) {\n      swiper.slideToClosest();\n      return;\n    }\n\n    if (!params.freeModeMomentum || timeDiff >= params.longSwipesMs) {\n      swiper.updateProgress();\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    }\n\n    return;\n  } // Find current slide\n\n\n  let stopIndex = 0;\n  let groupSize = swiper.slidesSizesGrid[0];\n\n  for (let i = 0; i < slidesGrid.length; i += params.slidesPerGroup) {\n    if (typeof slidesGrid[i + params.slidesPerGroup] !== 'undefined') {\n      if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + params.slidesPerGroup]) {\n        stopIndex = i;\n        groupSize = slidesGrid[i + params.slidesPerGroup] - slidesGrid[i];\n      }\n    } else if (currentPos >= slidesGrid[i]) {\n      stopIndex = i;\n      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];\n    }\n  } // Find current slide size\n\n\n  const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;\n\n  if (timeDiff > params.longSwipesMs) {\n    // Long touches\n    if (!params.longSwipes) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n\n    if (swiper.swipeDirection === 'next') {\n      if (ratio >= params.longSwipesRatio) swiper.slideTo(stopIndex + params.slidesPerGroup);else swiper.slideTo(stopIndex);\n    }\n\n    if (swiper.swipeDirection === 'prev') {\n      if (ratio > 1 - params.longSwipesRatio) swiper.slideTo(stopIndex + params.slidesPerGroup);else swiper.slideTo(stopIndex);\n    }\n  } else {\n    // Short swipes\n    if (!params.shortSwipes) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n\n    if (swiper.swipeDirection === 'next') {\n      swiper.slideTo(stopIndex + params.slidesPerGroup);\n    }\n\n    if (swiper.swipeDirection === 'prev') {\n      swiper.slideTo(stopIndex);\n    }\n  }\n}","map":{"version":3,"names":["Utils","event","swiper","data","touchEventsData","params","touches","rtlTranslate","rtl","$wrapperEl","slidesGrid","snapGrid","e","originalEvent","allowTouchCallbacks","emit","isTouched","isMoved","grabCursor","setGrabCursor","startMoving","allowSlideNext","allowSlidePrev","touchEndTime","now","timeDiff","touchStartTime","allowClick","updateClickedSlide","lastClickTime","clickTimeout","clearTimeout","nextTick","destroyed","swipeDirection","diff","currentTranslate","startTranslate","currentPos","followFinger","translate","freeMode","minTranslate","slideTo","activeIndex","maxTranslate","slides","length","freeModeMomentum","velocities","lastMoveEvent","pop","velocityEvent","distance","position","time","velocity","Math","abs","freeModeMinimumVelocity","freeModeMomentumVelocityRatio","momentumDuration","freeModeMomentumRatio","momentumDistance","newPosition","doBounce","afterBouncePosition","bounceAmount","freeModeMomentumBounceRatio","needsLoopFix","freeModeMomentumBounce","allowMomentumBounce","loop","centeredSlides","freeModeSticky","nextSlide","j","once","loopFix","slideToClosest","updateProgress","setTransition","setTranslate","transitionStart","animating","transitionEnd","speed","updateActiveIndex","updateSlidesClasses","longSwipesMs","stopIndex","groupSize","slidesSizesGrid","i","slidesPerGroup","ratio","longSwipes","longSwipesRatio","shortSwipes"],"sources":["D:/Morgana/front-end/vue/app/shopping/node_modules/swiper/src/components/core/events/onTouchEnd.js"],"sourcesContent":["import Utils from '../../../utils/utils';\n\nexport default function (event) {\n  const swiper = this;\n  const data = swiper.touchEventsData;\n\n  const {\n    params, touches, rtlTranslate: rtl, $wrapperEl, slidesGrid, snapGrid,\n  } = swiper;\n  let e = event;\n  if (e.originalEvent) e = e.originalEvent;\n  if (data.allowTouchCallbacks) {\n    swiper.emit('touchEnd', e);\n  }\n  data.allowTouchCallbacks = false;\n  if (!data.isTouched) {\n    if (data.isMoved && params.grabCursor) {\n      swiper.setGrabCursor(false);\n    }\n    data.isMoved = false;\n    data.startMoving = false;\n    return;\n  }\n  // Return Grab Cursor\n  if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n    swiper.setGrabCursor(false);\n  }\n\n  // Time diff\n  const touchEndTime = Utils.now();\n  const timeDiff = touchEndTime - data.touchStartTime;\n\n  // Tap, doubleTap, Click\n  if (swiper.allowClick) {\n    swiper.updateClickedSlide(e);\n    swiper.emit('tap', e);\n    if (timeDiff < 300 && (touchEndTime - data.lastClickTime) > 300) {\n      if (data.clickTimeout) clearTimeout(data.clickTimeout);\n      data.clickTimeout = Utils.nextTick(() => {\n        if (!swiper || swiper.destroyed) return;\n        swiper.emit('click', e);\n      }, 300);\n    }\n    if (timeDiff < 300 && (touchEndTime - data.lastClickTime) < 300) {\n      if (data.clickTimeout) clearTimeout(data.clickTimeout);\n      swiper.emit('doubleTap', e);\n    }\n  }\n\n  data.lastClickTime = Utils.now();\n  Utils.nextTick(() => {\n    if (!swiper.destroyed) swiper.allowClick = true;\n  });\n\n  if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {\n    data.isTouched = false;\n    data.isMoved = false;\n    data.startMoving = false;\n    return;\n  }\n  data.isTouched = false;\n  data.isMoved = false;\n  data.startMoving = false;\n\n  let currentPos;\n  if (params.followFinger) {\n    currentPos = rtl ? swiper.translate : -swiper.translate;\n  } else {\n    currentPos = -data.currentTranslate;\n  }\n\n  if (params.freeMode) {\n    if (currentPos < -swiper.minTranslate()) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n    if (currentPos > -swiper.maxTranslate()) {\n      if (swiper.slides.length < snapGrid.length) {\n        swiper.slideTo(snapGrid.length - 1);\n      } else {\n        swiper.slideTo(swiper.slides.length - 1);\n      }\n      return;\n    }\n\n    if (params.freeModeMomentum) {\n      if (data.velocities.length > 1) {\n        const lastMoveEvent = data.velocities.pop();\n        const velocityEvent = data.velocities.pop();\n\n        const distance = lastMoveEvent.position - velocityEvent.position;\n        const time = lastMoveEvent.time - velocityEvent.time;\n        swiper.velocity = distance / time;\n        swiper.velocity /= 2;\n        if (Math.abs(swiper.velocity) < params.freeModeMinimumVelocity) {\n          swiper.velocity = 0;\n        }\n        // this implies that the user stopped moving a finger then released.\n        // There would be no events with distance zero, so the last event is stale.\n        if (time > 150 || (Utils.now() - lastMoveEvent.time) > 300) {\n          swiper.velocity = 0;\n        }\n      } else {\n        swiper.velocity = 0;\n      }\n      swiper.velocity *= params.freeModeMomentumVelocityRatio;\n\n      data.velocities.length = 0;\n      let momentumDuration = 1000 * params.freeModeMomentumRatio;\n      const momentumDistance = swiper.velocity * momentumDuration;\n\n      let newPosition = swiper.translate + momentumDistance;\n      if (rtl) newPosition = -newPosition;\n\n      let doBounce = false;\n      let afterBouncePosition;\n      const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeModeMomentumBounceRatio;\n      let needsLoopFix;\n      if (newPosition < swiper.maxTranslate()) {\n        if (params.freeModeMomentumBounce) {\n          if (newPosition + swiper.maxTranslate() < -bounceAmount) {\n            newPosition = swiper.maxTranslate() - bounceAmount;\n          }\n          afterBouncePosition = swiper.maxTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.maxTranslate();\n        }\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\n      } else if (newPosition > swiper.minTranslate()) {\n        if (params.freeModeMomentumBounce) {\n          if (newPosition - swiper.minTranslate() > bounceAmount) {\n            newPosition = swiper.minTranslate() + bounceAmount;\n          }\n          afterBouncePosition = swiper.minTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.minTranslate();\n        }\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\n      } else if (params.freeModeSticky) {\n        let nextSlide;\n        for (let j = 0; j < snapGrid.length; j += 1) {\n          if (snapGrid[j] > -newPosition) {\n            nextSlide = j;\n            break;\n          }\n        }\n\n        if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {\n          newPosition = snapGrid[nextSlide];\n        } else {\n          newPosition = snapGrid[nextSlide - 1];\n        }\n        newPosition = -newPosition;\n      }\n      if (needsLoopFix) {\n        swiper.once('transitionEnd', () => {\n          swiper.loopFix();\n        });\n      }\n      // Fix duration\n      if (swiper.velocity !== 0) {\n        if (rtl) {\n          momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);\n        } else {\n          momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);\n        }\n      } else if (params.freeModeSticky) {\n        swiper.slideToClosest();\n        return;\n      }\n\n      if (params.freeModeMomentumBounce && doBounce) {\n        swiper.updateProgress(afterBouncePosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n        swiper.animating = true;\n        $wrapperEl.transitionEnd(() => {\n          if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;\n          swiper.emit('momentumBounce');\n\n          swiper.setTransition(params.speed);\n          swiper.setTranslate(afterBouncePosition);\n          $wrapperEl.transitionEnd(() => {\n            if (!swiper || swiper.destroyed) return;\n            swiper.transitionEnd();\n          });\n        });\n      } else if (swiper.velocity) {\n        swiper.updateProgress(newPosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n        if (!swiper.animating) {\n          swiper.animating = true;\n          $wrapperEl.transitionEnd(() => {\n            if (!swiper || swiper.destroyed) return;\n            swiper.transitionEnd();\n          });\n        }\n      } else {\n        swiper.updateProgress(newPosition);\n      }\n\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    } else if (params.freeModeSticky) {\n      swiper.slideToClosest();\n      return;\n    }\n\n    if (!params.freeModeMomentum || timeDiff >= params.longSwipesMs) {\n      swiper.updateProgress();\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    }\n    return;\n  }\n\n  // Find current slide\n  let stopIndex = 0;\n  let groupSize = swiper.slidesSizesGrid[0];\n  for (let i = 0; i < slidesGrid.length; i += params.slidesPerGroup) {\n    if (typeof slidesGrid[i + params.slidesPerGroup] !== 'undefined') {\n      if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + params.slidesPerGroup]) {\n        stopIndex = i;\n        groupSize = slidesGrid[i + params.slidesPerGroup] - slidesGrid[i];\n      }\n    } else if (currentPos >= slidesGrid[i]) {\n      stopIndex = i;\n      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];\n    }\n  }\n\n  // Find current slide size\n  const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;\n\n  if (timeDiff > params.longSwipesMs) {\n    // Long touches\n    if (!params.longSwipes) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n    if (swiper.swipeDirection === 'next') {\n      if (ratio >= params.longSwipesRatio) swiper.slideTo(stopIndex + params.slidesPerGroup);\n      else swiper.slideTo(stopIndex);\n    }\n    if (swiper.swipeDirection === 'prev') {\n      if (ratio > (1 - params.longSwipesRatio)) swiper.slideTo(stopIndex + params.slidesPerGroup);\n      else swiper.slideTo(stopIndex);\n    }\n  } else {\n    // Short swipes\n    if (!params.shortSwipes) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n    if (swiper.swipeDirection === 'next') {\n      swiper.slideTo(stopIndex + params.slidesPerGroup);\n    }\n    if (swiper.swipeDirection === 'prev') {\n      swiper.slideTo(stopIndex);\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}